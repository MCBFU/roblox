-- 强制优先加载playbreak（必写在最顶部）
local success, Library = pcall(function()
    return loadstring(game:HttpGet("https://gitee.com/cmbhbh/ycgui/raw/master/YCmain.lua"))()
end)

if not success then
    warn("playbreak加载失败！请更换有效链接，推荐备用链接：https://raw.githubusercontent.com/zzerexx/scripts/main/yc.lua")
    return
end

-- ========== 1. 先创建UI结构（顺序绝对不能乱） ==========
local Main = Library:CreateMainControl("playbreak")
local CombatWin = Library:CreateChildWindow("Monster") -- 全功能窗口
local VisualsWin = Library:CreateChildWindow("Expert")

Main:BindWindow("Monster", false)
Main:BindWindow("Expert", false)

-- ========== 2. 全局变量与核心服务 ==========
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Workspace = game:GetService("Workspace")
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera
local isAuraActive = false
local pipeInProgress = false
local renderConnection

-- 可配置参数（滑块控制）
local Settings = {
    auraDistance = 300,      -- 攻击距离
    attackInterval = 0.1,    -- 攻击间隔
    teleportHeight = 0,      -- 传送高度补偿
    pipeSpeed = 0.1          -- 每次传送间隔
}

-- 致命管道坐标
local allPipeLocations = {
    Vector3.new(43.06, 68.98, -254.75),Vector3.new(-0.53, 71.14, -329.87),Vector3.new(12.90, 94.29, -531.77),
    Vector3.new(-13.55, 87.70, -455.12),Vector3.new(-38.72, 87.45, -269.56),Vector3.new(-60.21, 105.48, -156.82),
    Vector3.new(-44.85, 112.19, -398.75),Vector3.new(73.64, 105.44, -404.03),Vector3.new(327.87, 37.94, 246.22),
    Vector3.new(386.97, 7.47, 331.48),Vector3.new(408.68, 34.45, 169.92),Vector3.new(335.75, 18.12, 205.47),
    Vector3.new(406.35, 33.01, 375.60),Vector3.new(359.39, 18.07, 437.61),Vector3.new(184.68, 18.11, 245.28),
    Vector3.new(312.79, 10.66, 351.58),Vector3.new(358.95, 18, 436.84),Vector3.new(358.95, 18, 436.84)
}

-- ========== 3. 辅助函数 ==========
-- 稳定获取根部件
local function getRootPart()
    local char = player.Character or player.CharacterAdded:Wait(5)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso")
end

-- 播放音效
local function playSound()
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://98446998103932"
    sound.Parent = SoundService
    sound:Play()
    sound.Ended:Connect(function() sound:Destroy() end)
end



-- Expert传送函数
local function performExpertTeleport(location, locationName)
    local character = player.Character
    if not character then 
        -- 这里不再显示悬浮窗
        return false 
    end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        -- 这里不再显示悬浮窗
        return false 
    end

    local teleportPos = Vector3.new(location.X, location.Y, location.Z)
    humanoidRootPart.CFrame = CFrame.new(teleportPos)
    return true
end

-- ========== 5. Expert功能 - 仙人模式（优化版） ==========
local isNinjaModeActive = false
local originalWalkSpeed = 16
local originalJumpPower = 50
local ninjaModeMultiplier = 2.5
local infiniteJumpEnabled = false
local noclipEnabled = false
local ninjaModeConnection = nil
local noclipConnection = nil

-- 穿墙功能（优化版）
local function enableNoclip()
    if noclipConnection then return end
    noclipConnection = RunService.Stepped:Connect(function()
        local character = player.Character
        if character and noclipEnabled and isNinjaModeActive then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
end

local function startNinjaMode()
    if isNinjaModeActive then return end

    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end

    originalWalkSpeed = humanoid.WalkSpeed
    originalJumpPower = humanoid.JumpPower
    isNinjaModeActive = true
    infiniteJumpEnabled = true
    noclipEnabled = true

    humanoid.WalkSpeed = originalWalkSpeed * ninjaModeMultiplier
    humanoid.JumpPower = originalJumpPower * 3

    -- 无限跳跃（优化防抽搐）
    ninjaModeConnection = UserInputService.JumpRequest:Connect(function()
        if infiniteJumpEnabled and character and character:FindFirstChild("Humanoid") then
            character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)

    enableNoclip()
end

local function stopNinjaMode()
    if not isNinjaModeActive then return end
    isNinjaModeActive = false
    infiniteJumpEnabled = false
    noclipEnabled = false

    -- 先关闭跳跃
    if ninjaModeConnection then
        ninjaModeConnection:Disconnect()
        ninjaModeConnection = nil
    end

    -- 然后关闭穿墙
    disableNoclip()

    -- 最后恢复属性（防止抽搐）
    task.wait(0.05)
    
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = originalWalkSpeed
            humanoid.JumpPower = originalJumpPower
        end
    end
end

-- ========== 角色重生处理 ==========
player.CharacterAdded:Connect(function(character)
    task.wait(0.5)
    if isNinjaModeActive then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = originalWalkSpeed * ninjaModeMultiplier
            humanoid.JumpPower = originalJumpPower * 3
            if noclipEnabled then
                enableNoclip()
            end
        end
    end
end)



-- Expert坐标定义
local expertLocations = {
    backroom = {X = 163.15, Y = 9, Z = 955.4},
    theaterFactory = {X = 0, Y = -297, Z = 0},
    sewer = {X = 356, Y = 528, Z = -179}
}

-- Expert传送函数
local function performExpertTeleport(location, locationName)
    local character = player.Character
    if not character then 
        createExpertNotification("角色未加载", Color3.fromRGB(200, 50, 50))
        return false 
    end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        createExpertNotification("根部件不存在", Color3.fromRGB(200, 50, 50))
        return false 
    end

    local teleportPos = Vector3.new(location.X, location.Y, location.Z)
    humanoidRootPart.CFrame = CFrame.new(teleportPos)
    createExpertNotification("已传送到"..locationName, Color3.fromRGB(50, 200, 50))
    return true
end

-- ========== 6. Monster窗口功能 ==========
-- 6.1 杀戮光环（保持原有逻辑）
local function auraMainLoop()
    local root = getRootPart()
    if not root or not isAuraActive then return end

    local nearestTarget, minDist = nil, math.huge
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and p.Character then
            local tRoot = p.Character:FindFirstChild("HumanoidRootPart")
            local hum = p.Character:FindFirstChild("Humanoid")
            if tRoot and hum and hum.Health > 0 then
                local dist = (root.Position - tRoot.Position).Magnitude
                if dist < Settings.auraDistance and dist < minDist then
                    minDist = dist
                    nearestTarget = tRoot
                end
            end
        end
    end

    if nearestTarget then
        root.CFrame = CFrame.new(nearestTarget.Position.X, nearestTarget.Position.Y + Settings.teleportHeight, nearestTarget.Position.Z)
        camera.CFrame = CFrame.lookAt(camera.CFrame.Position, nearestTarget.Position)
        if tick() % Settings.attackInterval < 0.01 then
            VirtualInputManager:SendMouseButtonEvent(0,0,0,true,game,0)
            task.wait(0.005)
            VirtualInputManager:SendMouseButtonEvent(0,0,0,false,game,0)
        end
    end
end

local function toggleAura(state)
    isAuraActive = state
    if state then
        renderConnection = RunService.RenderStepped:Connect(auraMainLoop)
        playSound()
        Library:Notify("✅ 杀戮光环已开启 | 距离："..Settings.auraDistance, true)
    else
        if renderConnection then renderConnection:Disconnect() end
        Library:Notify("❌ 杀戮光环已关闭", false)
    end
end

-- 6.2 致命管道
local function performAutoPipeTeleport()
    if pipeInProgress then
        Library:Notify("⚠ 传送中，请勿重复点击", false)
        return
    end
    pipeInProgress = true

    local root = getRootPart()
    if not root then
        pipeInProgress = false
        Library:Notify("❌ 根部件获取失败", false)
        return
    end

    Library:Notify("✅ 开始致命管道传送", true)
    local originalCFrame = root.CFrame

    task.spawn(function()
        for i, pos in ipairs(allPipeLocations) do
            local r = getRootPart()
            if not r or not pipeInProgress then break end
            r.CFrame = CFrame.new(pos.X, pos.Y + Settings.teleportHeight, pos.Z)
            task.wait(Settings.pipeSpeed)
        end
        local r = getRootPart()
        if r then r.CFrame = originalCFrame end
        Library:Notify("✅ 管道传送完成，已返回原点", true)
        pipeInProgress = false
    end)
end

-- 6.3 轮流传送
local cycleTeleportIndex = 1
local function performCycleTeleport()
    if pipeInProgress then
        Library:Notify("⚠ 传送中，无法执行", false)
        return
    end
    local root = getRootPart()
    if not root then
        Library:Notify("❌ 根部件获取失败", false)
        return
    end

    local validPlayers = {}
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and p.Character then
            local tRoot = p.Character:FindFirstChild("HumanoidRootPart")
            local hum = p.Character:FindFirstChild("Humanoid")
            if tRoot and hum and hum.Health > 0 then
                table.insert(validPlayers, p)
            end
        end
    end

    if #validPlayers == 0 then
        Library:Notify("❌ 无有效存活玩家", false)
        return
    end

    cycleTeleportIndex = cycleTeleportIndex % #validPlayers + 1
    local target = validPlayers[cycleTeleportIndex]
    local tRoot = target.Character:FindFirstChild("HumanoidRootPart")
    root.CFrame = CFrame.new(tRoot.Position.X, tRoot.Position.Y + Settings.teleportHeight, tRoot.Position.Z)
    Library:Notify(string.format("➡ 传送到玩家：%s", target.Name), true)
end

-- ========== 7. 播放Expert音效 ==========
local function playExpertSound()
    local success, soundError = pcall(function()
        local expertSound = Instance.new("Sound")
        expertSound.SoundId = "rbxassetid://7390036132"
        expertSound.Parent = SoundService
        expertSound:Play()
        expertSound.Ended:Connect(function() expertSound:Destroy() end)
    end)

    if not success then
        warn("Expert音频加载失败，但功能正常可用")
    end
end

-- ========== 8. 角色重生处理仙人模式 ==========
player.CharacterAdded:Connect(function(character)
    if isNinjaModeActive then
        task.wait(0.5)
        if isNinjaModeActive then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = originalWalkSpeed * ninjaModeMultiplier
                humanoid.JumpPower = originalJumpPower * 3
                if ninjaModeConnection then ninjaModeConnection:Disconnect() end
                ninjaModeConnection = UserInputService.JumpRequest:Connect(function()
                    if infiniteJumpEnabled and character and character:FindFirstChild("Humanoid") then
                        character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end)
            end
        end
    end
end)

-- ========== 9. 创建Monster窗口功能模块 ==========
-- 只保留攻击距离滑块和每次传送间隔滑块
local Aura = CombatWin:CreateModule("杀戮光环", toggleAura)
Aura:CreateSlider("攻击距离", 1, 500, 300, function(val)
    Settings.auraDistance = val
end)

local Pipe = CombatWin:CreateModule("致命管道", performAutoPipeTeleport)
Pipe:CreateSlider("每次传送间隔", 0.01, 1.0, 0.1, function(val)
    Settings.pipeSpeed = val
end)

CombatWin:CreateModule("轮流传送", performCycleTeleport)

-- ========== 10. 创建Expert窗口功能模块 ==========
VisualsWin:CreateModule("传送等候厅", function()
    performExpertTeleport(expertLocations.backroom, "等候厅")
end)

VisualsWin:CreateModule("万能传送", function()
    performExpertTeleport(expertLocations.theaterFactory, "剧院/工厂")
end)

VisualsWin:CreateModule("传送下水道", function()
    performExpertTeleport(expertLocations.sewer, "下水道")
end)

local NinjaModule = VisualsWin:CreateModule("仙人模式", function(state)
    if state then
        if startNinjaMode() then
            Library:Notify("✅ 仙人模式已开启", true)
        end
    else
        stopNinjaMode()
        Library:Notify("❌ 仙人模式已关闭", false)
    end
end)

-- ========== 11. 快捷键控制 ==========
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed then
        -- 右Ctrl开关杀戮光环
        if input.KeyCode == Enum.KeyCode.RightControl then
            isAuraActive = not isAuraActive
            toggleAura(isAuraActive)

        -- Expert功能快捷键
        elseif input.KeyCode == Enum.KeyCode.B then
            performExpertTeleport(expertLocations.backroom, "等候厅")
        elseif input.KeyCode == Enum.KeyCode.T then
            performExpertTeleport(expertLocations.theaterFactory, "剧院/工厂")
        elseif input.KeyCode == Enum.KeyCode.S then
            performExpertTeleport(expertLocations.sewer, "下水道")
        elseif input.KeyCode == Enum.KeyCode.N then
            if isNinjaModeActive then
                stopNinjaMode()
            else
                startNinjaMode()
            end
        end
    end
end)

-- ========== 新增：自杀选项 ==========
VisualsWin:CreateModule("自杀", function()
    local character = player.Character
    if not character then 
        Library:Notify("❌ 角色未加载", false)
        return 
    end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then 
        Library:Notify("❌ 未找到人形对象", false)
        return 
    end

    -- 直接设置血量为0
    humanoid.Health = 0
    Library:Notify("✅ 血量已归零", true)
end)
-- ========== 12. 初始化 ==========
-- 播放Expert加载音效
task.wait(0.5)
playExpertSound()

-- 设置playbreak
Library:SetupSettings()

-- 显示加载完成通知
Library:Notify("欢迎使用", true)
-- 完整搜索所有GUI
local translation = {
    ["By BeiHai"] = "BY | 渔炒鱼",
    ["YC GUI"] = "playbreak",
}

-- 检查三个地方
local places = {
    game.Players.LocalPlayer:WaitForChild("PlayerGui"),
    game:GetService("CoreGui"),
    game:GetService("StarterGui")
}

for _, gui in pairs(places) do
    for _, obj in pairs(gui:GetDescendants()) do
        if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
            local text = obj.Text
            if text then
                for eng, chi in pairs(translation) do
                    if text == eng then
                        obj.Text = chi
                        break
                    elseif text:find(eng, 1, true) then
                        obj.Text = text:gsub(eng, chi)
                        break
                    end
                end
            end
        end
    end
end